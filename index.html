async typesetElement(element) {
    const regex = /(\$[^$]+\$|\$\$[^$]+\$\$)/g;
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false);
    const textNodes = [];
    while(walker.nextNode()) textNodes.push(walker.currentNode);

    for (let node of textNodes) {
        if (node.parentNode.tagName === 'MJX-CONTAINER' || node.parentNode.tagName === 'STYLE') continue;
        const text = node.nodeValue;
        if (!text.match(regex)) continue;

        const fragment = document.createDocumentFragment();
        let lastIndex = 0; regex.lastIndex = 0; let match;

        while ((match = regex.exec(text)) !== null) {
            if (match.index > lastIndex) fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
            
            const fullTex = match[0];
            const cleanTex = fullTex.replace(/^\$\$|\$\$?$/g, '');
            const isDisplay = fullTex.startsWith('$$');

            try {
                // 변경: tex2svgPromise의 반환값을 바로 mjxContainer로 사용
                const mjxContainer = await MathJax.tex2svgPromise(cleanTex, { display: isDisplay });
                // Atom화 로직(절대 변경 금지)
                if (mjxContainer) {
                    mjxContainer.setAttribute('data-tex', cleanTex);
                    mjxContainer.setAttribute('contenteditable', 'false'); // Atom화: 커서 진입 방지
                    mjxContainer.classList.add('math-atom');
                    fragment.appendChild(mjxContainer);
                } else {
                    fragment.appendChild(document.createTextNode(fullTex));
                }
            } catch(e) { 
                console.error(e);
                fragment.appendChild(document.createTextNode(fullTex)); 
            }
            lastIndex = regex.lastIndex;
        }
        if (lastIndex < text.length) fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
        node.parentNode.replaceChild(fragment, node);
    }
}
